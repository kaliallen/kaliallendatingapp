export declare class IndexManager {
    indexes: IIndexEntry[];
    fieldOverrides: IFieldOverride[];
    addIndex<T>(collectionGroup: string, queryScope: QueryScope): IndexBuilder<T>;
    addOverride<T>(collectionGroup: string, fieldPath: KeyOf<T>): FieldOverrideBuilder<T>;
    toObject(): IFirestoreIndex;
    toJSON(space?: string | number): string;
}
declare class IndexBuilder<T> {
    private parent;
    readonly entry: IIndexEntry<T>;
    constructor(parent: IndexManager, collectionGroup: string, queryScope: QueryScope);
    field(fieldPath: keyof T | string, order?: IndexFieldOrder): this;
    add(): IndexManager;
}
declare class FieldOverrideBuilder<T> {
    private parent;
    private readonly entry;
    constructor(parent: IndexManager, collectionGroup: string, fieldPath: KeyOf<T>);
    order(queryScope: QueryScope, order: IndexFieldOrder): this;
    array(queryScope: QueryScope, arrayConfig: 'contain'): this;
    add(): IndexManager;
}
export interface IFirestoreIndex {
    indexes: IIndexEntry[];
    fieldOverrides: IFieldOverride[];
}
export interface IIndexEntry<T = any> {
    collectionGroup: string;
    queryScope: QueryScope;
    fields: IIndexField<T>[];
}
export interface IIndexField<T> {
    fieldPath: KeyOf<T>;
    order?: IndexFieldOrder;
}
export interface IFieldOverride<T = any> {
    collectionGroup: string;
    fieldPath: KeyOf<T>;
    indexes: IFieldOverrideIndex[];
}
export declare type IFieldOverrideIndex = {
    queryScope: QueryScope;
    order?: IndexFieldOrder;
} | {
    queryScope: QueryScope;
    arrayConfig?: 'contain';
};
declare type KeyOf<T> = keyof T | string;
export declare enum IndexFieldOrder {
    Asc = "ASCENDING",
    Desc = "DESCENDING"
}
export declare enum QueryScope {
    Collection = "COLLECTION",
    CollectionGroup = "COLLECTION_GROUP"
}
export {};
//# sourceMappingURL=index_manger.d.ts.map